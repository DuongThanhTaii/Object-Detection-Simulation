<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ultimate Object Detection Simulator (NMS & Metrics)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      }
      canvas {
        touch-action: none;
      }
      .sidebar {
        scrollbar-width: thin;
      }
      .scientific-text {
        font-family: "Georgia", serif;
        line-height: 1.6;
      }
      /* Custom scrollbar for tables */
      .table-scroll::-webkit-scrollbar {
        width: 6px;
        height: 6px;
      }
      .table-scroll::-webkit-scrollbar-thumb {
        background: #cbd5e1;
        border-radius: 3px;
      }
    </style>
  </head>
  <body class="bg-gray-100 h-screen flex flex-col overflow-hidden">
    <!-- Header -->
    <header
      class="bg-slate-900 text-white p-3 shadow-md flex justify-between items-center z-20"
    >
      <div class="flex items-center gap-3">
        <div class="w-10 h-10 rounded flex items-center justify-center">
          <img
            src="https://hcmue.edu.vn/images/Faculty_Logos/CNTT.png"
            alt=""
          />
        </div>
        <div>
          <h1 class="text-lg font-bold leading-tight">Object Detection</h1>
          <p class="text-xs text-gray-400">
            Nhóm 01 - Advanced Simulator: IoU, NMS, mAP & Confusion Matrix
          </p>
        </div>
      </div>
      <div class="flex gap-3">
        <button
          onclick="downloadReport()"
          class="bg-indigo-600 hover:bg-indigo-500 text-white px-3 py-1 rounded text-sm font-bold transition flex items-center gap-2"
        >
          <i class="fas fa-camera"></i>
          Chụp Báo Cáo
        </button>
      </div>
    </header>

    <div class="flex flex-1 overflow-hidden">
      <!-- Sidebar Controls -->
      <aside
        class="w-[420px] bg-white shadow-xl overflow-y-auto flex flex-col border-r z-10"
      >
        <div class="p-4 space-y-4 pb-20">
          <!-- 1. Drawing Tools -->
          <div
            class="bg-white p-4 rounded-lg border border-gray-200 shadow-sm relative overflow-hidden group"
          >
            <div class="absolute top-0 left-0 w-1 h-full bg-blue-500"></div>
            <h2
              class="font-bold text-gray-800 text-sm mb-3 uppercase tracking-wider flex justify-between"
            >
              1. Công cụ vẽ
              <span
                class="text-gray-400 text-xs normal-case cursor-help"
                title="Chuột trái vẽ, Chuột phải xóa"
              >
                Hdsd: Chuột phải để xóa
              </span>
            </h2>

            <div class="flex gap-2 mb-3">
              <button
                id="btn-gt"
                class="flex-1 py-2 px-2 rounded bg-green-600 text-white text-sm font-bold hover:bg-green-700 transition shadow-sm ring-2 ring-offset-1 ring-green-600"
                onclick="setMode('gt')"
              >
                <i class="fas fa-cube mr-1"></i>
                Ground Truth
              </button>
              <button
                id="btn-pred"
                class="flex-1 py-2 px-2 rounded bg-gray-100 text-gray-600 text-sm font-bold hover:bg-red-50 transition"
                onclick="setMode('pred')"
              >
                <i class="fas fa-vector-square mr-1"></i>
                Prediction
              </button>
            </div>

            <div
              id="conf-control"
              class="mb-3 hidden transition-all bg-gray-50 p-2 rounded border border-gray-200"
            >
              <div
                class="flex justify-between text-xs mb-1 font-semibold text-gray-700"
              >
                <span>Confidence Score:</span>
                <span id="conf-val" class="text-indigo-600">0.90</span>
              </div>
              <input
                type="range"
                id="conf-slider"
                min="0.05"
                max="1.0"
                step="0.05"
                value="0.9"
                class="w-full h-1 bg-gray-300 rounded-lg appearance-none cursor-pointer accent-indigo-600"
              />
            </div>

            <button
              onclick="clearCanvas()"
              class="w-full py-1 text-xs text-red-500 border border-red-200 rounded hover:bg-red-50 font-semibold transition"
            >
              <i class="fas fa-trash-alt mr-1"></i>
              Xóa toàn bộ dữ liệu
            </button>
          </div>

          <!-- 2. Parameters (NMS & IoU) -->
          <div
            class="bg-white p-4 rounded-lg border border-gray-200 shadow-sm relative overflow-hidden"
          >
            <div class="absolute top-0 left-0 w-1 h-full bg-purple-500"></div>
            <h2
              class="font-bold text-gray-800 text-sm mb-3 uppercase tracking-wider"
            >
              2. Tham số thuật toán
            </h2>

            <!-- IoU Threshold -->
            <div class="mb-4">
              <div class="flex justify-between text-xs mb-1">
                <span class="font-semibold text-gray-700">
                  IoU Threshold (Matching):
                </span>
                <span id="iou-val" class="font-bold text-purple-600">0.50</span>
              </div>
              <input
                type="range"
                id="iou-slider"
                min="0.1"
                max="0.95"
                step="0.05"
                value="0.5"
                class="w-full h-1 bg-purple-200 rounded-lg appearance-none cursor-pointer accent-purple-600"
                oninput="updateParams()"
              />
              <p class="text-[10px] text-gray-400 mt-1">
                Ngưỡng để xác định box dự đoán là đúng (Positive).
              </p>
            </div>

            <!-- NMS Threshold -->
            <div class="mb-4 border-t pt-3 border-dashed border-gray-200">
              <div class="flex justify-between text-xs mb-1">
                <span class="font-semibold text-gray-700">NMS Threshold:</span>
                <span id="nms-val" class="font-bold text-orange-600">0.50</span>
              </div>
              <div class="flex items-center gap-2">
                <input
                  type="checkbox"
                  id="use-nms"
                  class="w-4 h-4 text-orange-600 rounded"
                  onchange="updateParams()"
                />
                <input
                  type="range"
                  id="nms-slider"
                  min="0.1"
                  max="1.0"
                  step="0.05"
                  value="0.5"
                  class="flex-1 h-1 bg-orange-200 rounded-lg appearance-none cursor-pointer accent-orange-600"
                  oninput="updateParams()"
                />
              </div>
              <p class="text-[10px] text-gray-400 mt-1">
                Bật checkbox để kích hoạt Non-Maximum Suppression (Loại bỏ trùng
                lặp).
              </p>
            </div>

            <!-- View Options -->
            <div class="flex flex-wrap gap-2 text-xs">
              <label
                class="flex items-center gap-1 cursor-pointer bg-gray-50 px-2 py-1 rounded border"
              >
                <input type="checkbox" id="show-grid" onchange="drawAll()" />
                <span>TN Grid</span>
              </label>
              <label
                class="flex items-center gap-1 cursor-pointer bg-gray-50 px-2 py-1 rounded border"
              >
                <input
                  type="checkbox"
                  id="show-intersection"
                  checked
                  onchange="drawAll()"
                />
                <span>Tô màu IoU</span>
              </label>
            </div>
          </div>

          <button
            onclick="calculateMetrics()"
            class="w-full py-3 bg-indigo-600 text-white rounded-lg shadow-lg hover:bg-indigo-700 font-bold text-sm uppercase tracking-wide transition transform hover:scale-[1.02]"
          >
            <i class="fas fa-play-circle mr-2"></i>
            Chạy Phân Tích
          </button>

          <!-- 3. Results Panel -->
          <div id="results-panel" class="hidden space-y-4 animate-fade-in-up">
            <!-- Confusion Matrix -->
            <div
              class="bg-white p-3 rounded-lg border border-gray-200 shadow-sm"
            >
              <h3 class="text-xs font-bold text-gray-500 uppercase mb-2">
                Confusion Matrix
              </h3>
              <div class="grid grid-cols-4 gap-1 text-center">
                <div class="bg-green-50 p-2 rounded border border-green-200">
                  <div class="text-lg font-bold text-green-700" id="tp-count">
                    0
                  </div>
                  <div class="text-[10px] font-bold text-green-800">TP</div>
                </div>
                <div class="bg-red-50 p-2 rounded border border-red-200">
                  <div class="text-lg font-bold text-red-700" id="fp-count">
                    0
                  </div>
                  <div class="text-[10px] font-bold text-red-800">FP</div>
                </div>
                <div class="bg-orange-50 p-2 rounded border border-orange-200">
                  <div class="text-lg font-bold text-orange-700" id="fn-count">
                    0
                  </div>
                  <div class="text-[10px] font-bold text-orange-800">FN</div>
                </div>
                <div
                  class="bg-gray-100 p-2 rounded border border-gray-200 opacity-75"
                >
                  <div class="text-lg font-bold text-gray-600" id="tn-count">
                    -
                  </div>
                  <div class="text-[10px] font-bold text-gray-600">TN</div>
                </div>
              </div>
            </div>

            <!-- Metrics Report -->
            <div
              class="bg-white rounded-lg border border-gray-200 shadow-sm overflow-hidden"
            >
              <table class="w-full text-xs text-left">
                <thead class="bg-gray-50 text-gray-500 font-semibold border-b">
                  <tr>
                    <th class="px-3 py-2">Metric</th>
                    <th class="px-3 py-2 text-right">Giá trị</th>
                  </tr>
                </thead>
                <tbody class="divide-y divide-gray-100 text-gray-700">
                  <tr>
                    <td class="px-3 py-2">Precision</td>
                    <td
                      class="px-3 py-2 text-right font-mono font-bold"
                      id="precision-val"
                    >
                      0.00
                    </td>
                  </tr>
                  <tr>
                    <td class="px-3 py-2">Recall</td>
                    <td
                      class="px-3 py-2 text-right font-mono font-bold"
                      id="recall-val"
                    >
                      0.00
                    </td>
                  </tr>
                  <tr>
                    <td class="px-3 py-2">F1-Score</td>
                    <td
                      class="px-3 py-2 text-right font-mono font-bold"
                      id="f1-val"
                    >
                      0.00
                    </td>
                  </tr>
                  <tr class="bg-indigo-50">
                    <td class="px-3 py-2 font-bold text-indigo-700">
                      Average Precision (AP)
                    </td>
                    <td
                      class="px-3 py-2 text-right font-mono font-bold text-indigo-700 text-sm"
                      id="ap-val"
                    >
                      0.00
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>

            <!-- Chart -->
            <div class="bg-white p-2 rounded border shadow-sm">
              <canvas id="prChart" height="180"></canvas>
            </div>

            <!-- Scientific Conclusion -->
            <div class="bg-blue-50 p-3 rounded-lg border-l-4 border-blue-500">
              <p
                id="scientific-conclusion"
                class="scientific-text text-xs text-blue-900 text-justify italic"
              ></p>
            </div>

            <!-- Detailed Log Table -->
            <div class="bg-white rounded border border-gray-200 shadow-sm">
              <div
                class="bg-gray-100 px-3 py-2 border-b text-xs font-bold text-gray-600 uppercase"
              >
                Chi tiết dự đoán (Log)
              </div>
              <div class="max-h-40 overflow-y-auto table-scroll">
                <table class="w-full text-[10px] text-left">
                  <thead class="bg-gray-50 sticky top-0">
                    <tr>
                      <th class="px-2 py-1">ID</th>
                      <th class="px-2 py-1">Conf</th>
                      <th class="px-2 py-1">IoU (Max)</th>
                      <th class="px-2 py-1">Status</th>
                    </tr>
                  </thead>
                  <tbody id="log-table-body" class="divide-y">
                    <!-- Rows injected via JS -->
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </div>
      </aside>

      <!-- Main Canvas Area -->
      <main
        class="flex-1 bg-slate-200 relative flex flex-col items-center justify-center p-4 overflow-hidden"
        id="canvas-container"
      >
        <!-- Legend -->
        <div
          class="bg-white/95 backdrop-blur shadow-lg px-4 py-2 rounded-full mb-4 flex gap-4 text-xs font-bold z-10 border border-gray-200"
        >
          <div class="flex items-center gap-1">
            <div class="w-3 h-3 bg-green-500 rounded-sm"></div>
            TP
          </div>
          <div class="flex items-center gap-1">
            <div class="w-3 h-3 bg-red-500 rounded-sm"></div>
            FP
          </div>
          <div class="flex items-center gap-1">
            <div
              class="w-3 h-3 border-2 border-orange-400 border-dashed rounded-sm"
            ></div>
            FN
          </div>
          <div class="flex items-center gap-1 opacity-50">
            <div class="w-3 h-3 bg-gray-400 rounded-sm"></div>
            Suppressed (NMS)
          </div>
          <div class="flex items-center gap-1 text-purple-600">
            <div
              class="w-3 h-3 bg-purple-500/30 border border-purple-500 rounded-sm"
            ></div>
            IoU Area
          </div>
        </div>

        <div
          class="relative shadow-2xl border-4 border-slate-700 bg-white cursor-crosshair group"
          style="width: 650px; height: 650px"
        >
          <canvas
            id="mainCanvas"
            width="650"
            height="650"
            class="absolute top-0 left-0 z-10"
          ></canvas>
          <!-- Tooltip -->
          <div
            id="hover-tooltip"
            class="absolute hidden bg-black/80 text-white text-xs p-2 rounded pointer-events-none z-50 whitespace-pre"
          ></div>

          <div
            class="absolute bottom-2 right-2 text-xs text-gray-300 select-none font-mono"
          >
            650x650 px
          </div>
        </div>

        <div class="mt-4 text-xs text-gray-500 italic">
          *Mẹo: Nhấn chuột phải vào box để xóa. Kéo thả để vẽ.
        </div>
      </main>
    </div>

    <script>
      // --- Configuration ---
      const canvas = document.getElementById("mainCanvas");
      const ctx = canvas.getContext("2d");
      const tooltip = document.getElementById("hover-tooltip");
      const CANVAS_SIZE = 650;
      const GRID_SIZE = 50;

      // --- State ---
      let groundTruths = []; // {x, y, w, h, id, status}
      let predictions = []; // {x, y, w, h, score, id, status, iou, bestGtId}
      let currentMode = "gt";
      let isDrawing = false;
      let startX, startY;
      let currentRect = null;
      let prChartInstance = null;
      let isAnalyzed = false;

      // --- UI Refs ---
      const btnGt = document.getElementById("btn-gt");
      const btnPred = document.getElementById("btn-pred");
      const confSlider = document.getElementById("conf-slider");
      const confVal = document.getElementById("conf-val");
      const iouSlider = document.getElementById("iou-slider");
      const iouVal = document.getElementById("iou-val");
      const nmsSlider = document.getElementById("nms-slider");
      const nmsVal = document.getElementById("nms-val");
      const useNmsCheck = document.getElementById("use-nms");
      const showGridCheck = document.getElementById("show-grid");
      const showInterCheck = document.getElementById("show-intersection");

      // --- Event Listeners ---
      const updateSliderVal = (slider, display) => {
        slider.addEventListener("input", (e) => {
          display.textContent = parseFloat(e.target.value).toFixed(2);
          if (isAnalyzed) calculateMetrics();
        });
      };
      updateSliderVal(confSlider, confVal);
      updateSliderVal(iouSlider, iouVal);
      updateSliderVal(nmsSlider, nmsVal);

      // Canvas Interaction
      canvas.addEventListener("mousedown", (e) => {
        if (e.button === 2) return; // Right click handled by contextmenu
        const rect = canvas.getBoundingClientRect();
        startX = e.clientX - rect.left;
        startY = e.clientY - rect.top;
        isDrawing = true;
      });

      canvas.addEventListener("mousemove", (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        // Hover logic
        if (!isDrawing) {
          handleHover(x, y);
          return;
        }

        // Drawing logic
        currentRect = {
          x: Math.min(startX, x),
          y: Math.min(startY, y),
          w: Math.abs(x - startX),
          h: Math.abs(y - startY),
        };
        drawAll();

        // Draw guideline
        ctx.beginPath();
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.strokeStyle = currentMode === "gt" ? "#16a34a" : "#4f46e5";
        ctx.rect(currentRect.x, currentRect.y, currentRect.w, currentRect.h);
        ctx.stroke();
        ctx.setLineDash([]);

        // Draw dimensions tooltip while drawing
        ctx.fillStyle = "black";
        ctx.font = "10px monospace";
        ctx.fillText(
          `${Math.round(currentRect.w)}x${Math.round(currentRect.h)}`,
          currentRect.x,
          currentRect.y - 5
        );
      });

      canvas.addEventListener("mouseup", () => {
        if (
          isDrawing &&
          currentRect &&
          currentRect.w > 5 &&
          currentRect.h > 5
        ) {
          const box = { ...currentRect, id: Date.now() };
          if (currentMode === "gt") {
            groundTruths.push(box);
          } else {
            box.score = parseFloat(confSlider.value);
            predictions.push(box);
          }
          // Reset analysis if user modifies data
          isAnalyzed = false;
          document.getElementById("results-panel").classList.add("hidden");
        }
        isDrawing = false;
        currentRect = null;
        drawAll();
      });

      // Right click to delete
      canvas.addEventListener("contextmenu", (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        // Delete logic (reverse order to delete top-most)
        let deleted = false;
        // Check Preds first
        for (let i = predictions.length - 1; i >= 0; i--) {
          const b = predictions[i];
          if (x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h) {
            predictions.splice(i, 1);
            deleted = true;
            break;
          }
        }
        // Check GTs if no pred deleted
        if (!deleted) {
          for (let i = groundTruths.length - 1; i >= 0; i--) {
            const b = groundTruths[i];
            if (x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h) {
              groundTruths.splice(i, 1);
              deleted = true;
              break;
            }
          }
        }
        if (deleted) {
          isAnalyzed = false;
          document.getElementById("results-panel").classList.add("hidden");
          drawAll();
        }
      });

      function setMode(mode) {
        currentMode = mode;
        const activeClass = "ring-2 ring-offset-1 shadow-sm";
        const confCtrl = document.getElementById("conf-control");

        if (mode === "gt") {
          btnGt.className = `flex-1 py-2 px-2 rounded bg-green-600 text-white text-sm font-bold transition ${activeClass} ring-green-600`;
          btnPred.className =
            "flex-1 py-2 px-2 rounded bg-gray-100 text-gray-600 text-sm font-bold hover:bg-red-50 transition";
          confCtrl.classList.add("hidden");
        } else {
          btnGt.className =
            "flex-1 py-2 px-2 rounded bg-gray-100 text-gray-600 text-sm font-bold hover:bg-green-50 transition";
          btnPred.className = `flex-1 py-2 px-2 rounded bg-indigo-600 text-white text-sm font-bold transition ${activeClass} ring-indigo-600`;
          confCtrl.classList.remove("hidden");
        }
      }

      function clearCanvas() {
        groundTruths = [];
        predictions = [];
        isAnalyzed = false;
        document.getElementById("results-panel").classList.add("hidden");
        drawAll();
      }

      function updateParams() {
        nmsVal.textContent = nmsSlider.value;
        iouVal.textContent = iouSlider.value;
        if (isAnalyzed) calculateMetrics();
      }

      // --- Math Helpers ---
      function getIntersection(boxA, boxB) {
        const xA = Math.max(boxA.x, boxB.x);
        const yA = Math.max(boxA.y, boxB.y);
        const xB = Math.min(boxA.x + boxA.w, boxB.x + boxB.w);
        const yB = Math.min(boxA.y + boxA.h, boxB.y + boxB.h);
        const w = Math.max(0, xB - xA);
        const h = Math.max(0, yB - yA);
        if (w === 0 || h === 0) return null;
        return { x: xA, y: yA, w: w, h: h, area: w * h };
      }

      function calculateIoU(boxA, boxB) {
        const inter = getIntersection(boxA, boxB);
        if (!inter) return 0;
        const union = boxA.w * boxA.h + boxB.w * boxB.h - inter.area;
        return union === 0 ? 0 : inter.area / union;
      }

      // --- Rendering ---
      function drawAll() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 1. Grid (TN)
        if (showGridCheck.checked) {
          drawGrid();
        }

        // 2. Ground Truths
        groundTruths.forEach((gt) => {
          let color = "#16a34a";
          let dash = [];
          let label = "GT";

          if (isAnalyzed && gt.status === "FN") {
            color = "#fb923c"; // Orange
            dash = [5, 5];
            label = "Missed (FN)";
          }

          ctx.beginPath();
          ctx.lineWidth = 2;
          ctx.strokeStyle = color;
          ctx.setLineDash(dash);
          ctx.rect(gt.x, gt.y, gt.w, gt.h);
          ctx.stroke();
          ctx.setLineDash([]);

          // Label
          ctx.fillStyle = color;
          ctx.font = "bold 11px sans-serif";
          const textW = ctx.measureText(label).width;
          ctx.fillRect(gt.x, gt.y - 16, textW + 6, 16);
          ctx.fillStyle = "white";
          ctx.fillText(label, gt.x + 3, gt.y - 4);
        });

        // 3. Predictions
        // Draw suppressed boxes first (so they are behind)
        predictions.forEach((pred) => {
          if (isAnalyzed && pred.status === "SUPPRESSED") {
            drawBox(pred, "#9ca3af", "Suppressed", 1, true);
          }
        });

        // Draw Active Predictions
        predictions.forEach((pred) => {
          if (isAnalyzed && pred.status === "SUPPRESSED") return;

          let color = "#4f46e5";
          let label = `Conf: ${pred.score.toFixed(2)}`;
          let lineWidth = 2;

          if (isAnalyzed) {
            if (pred.status === "TP") {
              color = "#22c55e"; // Green
              label = `TP (${pred.iou.toFixed(2)})`;
              lineWidth = 3;
            } else {
              color = "#ef4444"; // Red
              label = `FP (${pred.iou ? pred.iou.toFixed(2) : "0.00"})`;
              lineWidth = 2;
            }
          }
          drawBox(pred, color, label, lineWidth);
        });

        // 4. Draw Intersections (Visualizing IoU)
        if (isAnalyzed && showInterCheck.checked) {
          predictions.forEach((pred) => {
            if (pred.status === "TP" && pred.bestGtId) {
              const gt = groundTruths.find((g) => g.id === pred.bestGtId);
              if (gt) {
                const inter = getIntersection(pred, gt);
                if (inter) {
                  ctx.fillStyle = "rgba(168, 85, 247, 0.4)"; // Purple transparent
                  ctx.fillRect(inter.x, inter.y, inter.w, inter.h);
                  ctx.strokeStyle = "#a855f7";
                  ctx.lineWidth = 1;
                  ctx.strokeRect(inter.x, inter.y, inter.w, inter.h);
                }
              }
            }
          });
        }
      }

      function drawBox(box, color, text, lw, dashed = false) {
        ctx.beginPath();
        ctx.lineWidth = lw;
        ctx.strokeStyle = color;
        if (dashed) ctx.setLineDash([4, 4]);
        ctx.rect(box.x, box.y, box.w, box.h);
        ctx.stroke();
        ctx.setLineDash([]);

        // Fill slightly
        ctx.fillStyle = color + "20"; // Hex opacity
        ctx.fill();

        // Label
        ctx.fillStyle = color;
        ctx.font = "10px sans-serif";
        const w = ctx.measureText(text).width;
        ctx.fillRect(box.x, box.y - 14, w + 4, 14);
        ctx.fillStyle = "white";
        ctx.fillText(text, box.x + 2, box.y - 3);
      }

      function drawGrid() {
        ctx.strokeStyle = "#e2e8f0";
        ctx.lineWidth = 1;
        let tn = 0;
        const cols = CANVAS_SIZE / GRID_SIZE;
        for (let i = 0; i < cols; i++) {
          for (let j = 0; j < cols; j++) {
            const cx = i * GRID_SIZE;
            const cy = j * GRID_SIZE;

            // Simple logic: if grid cell touches NO box, it's TN
            let touch = false;
            const check = (b) =>
              !(
                cx > b.x + b.w ||
                cx + GRID_SIZE < b.x ||
                cy > b.y + b.h ||
                cy + GRID_SIZE < b.y
              );

            // Only check active preds and GTs
            const activePreds = isAnalyzed
              ? predictions.filter((p) => p.status !== "SUPPRESSED")
              : predictions;

            if (groundTruths.some(check) || activePreds.some(check)) {
              touch = true;
            }

            if (!touch) {
              ctx.strokeRect(cx, cy, GRID_SIZE, GRID_SIZE);
              ctx.fillStyle = "#f8fafc";
              ctx.fillRect(cx + 1, cy + 1, GRID_SIZE - 2, GRID_SIZE - 2);
              if (Math.random() > 0.9) {
                // Randomly draw TN label to reduce clutter
                ctx.fillStyle = "#cbd5e1";
                ctx.font = "9px sans-serif";
                ctx.fillText("TN", cx + 18, cy + 30);
              }
              tn++;
            }
          }
        }
        if (isAnalyzed) document.getElementById("tn-count").textContent = tn;
      }

      function handleHover(x, y) {
        // Find top box
        let found = null;
        // Check preds
        for (let b of predictions) {
          if (x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h) {
            found = { b, type: "Pred" };
            break;
          } // top is last usually, but visually whatever
        }
        if (!found) {
          for (let b of groundTruths) {
            if (x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h) {
              found = { b, type: "GT" };
              break;
            }
          }
        }

        if (found) {
          canvas.style.cursor = "pointer";
          tooltip.style.display = "block";
          tooltip.style.left = x + 15 + "px";
          tooltip.style.top = y + 15 + "px";
          let txt = `Type: ${found.type}`;
          if (found.type === "Pred") {
            txt += `\nConf: ${found.b.score.toFixed(2)}`;
            if (isAnalyzed)
              txt += `\nStatus: ${found.b.status}\nIoU: ${
                found.b.iou?.toFixed(2) || 0
              }`;
          } else if (isAnalyzed) {
            txt += `\nStatus: ${found.b.status}`;
          }
          tooltip.textContent = txt;
        } else {
          canvas.style.cursor = "crosshair";
          tooltip.style.display = "none";
        }
      }

      // --- CORE ALGORITHM ---
      function calculateMetrics() {
        if (groundTruths.length === 0 && predictions.length === 0) return;

        isAnalyzed = true;
        document.getElementById("results-panel").classList.remove("hidden");

        const iouThresh = parseFloat(iouSlider.value);
        const nmsThresh = parseFloat(nmsSlider.value);
        const doNms = useNmsCheck.checked;

        // 1. Reset States
        groundTruths.forEach((gt) => (gt.status = "FN"));
        predictions.forEach((p) => {
          p.status = "UNKNOWN";
          p.iou = 0;
          p.bestGtId = null;
        });

        // 2. NMS (Non-Maximum Suppression)
        // Sort by confidence high -> low
        let sortedPreds = [...predictions].sort((a, b) => b.score - a.score);

        if (doNms) {
          const active = [];
          while (sortedPreds.length > 0) {
            const current = sortedPreds.shift();
            active.push(current);

            // Filter remaining: if IoU with current > NMS thresh, suppress it
            const keep = [];
            const suppress = [];
            sortedPreds.forEach((other) => {
              const iou = calculateIoU(current, other);
              if (iou > nmsThresh) {
                other.status = "SUPPRESSED";
                other.iou = iou; // Log why it was suppressed
                suppress.push(other);
              } else {
                keep.push(other);
              }
            });
            sortedPreds = keep;
          }
          // predictions array already holds references, so status updates persist
          sortedPreds = active; // For matching step, only use active ones
        }

        // 3. Matching (Greedy IoU)
        // Only consider non-suppressed preds
        const activePreds = predictions
          .filter((p) => p.status !== "SUPPRESSED")
          .sort((a, b) => b.score - a.score);

        let tp = 0,
          fp = 0;
        let accTP = 0,
          accFP = 0;
        const totalGT = groundTruths.length;
        const prPoints = [];

        activePreds.forEach((pred) => {
          let bestIoU = 0;
          let bestGt = null;

          groundTruths.forEach((gt) => {
            const iou = calculateIoU(pred, gt);
            if (iou > bestIoU) {
              bestIoU = iou;
              bestGt = gt;
            }
          });

          pred.iou = bestIoU;
          pred.bestGtId = bestGt ? bestGt.id : null;

          if (bestIoU >= iouThresh && bestGt) {
            if (bestGt.status === "FN") {
              pred.status = "TP";
              bestGt.status = "DETECTED";
              tp++;
              accTP++;
            } else {
              pred.status = "FP"; // Duplicate detection
              fp++;
              accFP++;
            }
          } else {
            pred.status = "FP";
            fp++;
            accFP++;
          }

          // PR Calculation point
          const precision = accTP / (accTP + accFP);
          const recall = totalGT === 0 ? 0 : accTP / totalGT;
          prPoints.push({ x: recall, y: precision });
        });

        // FP also includes suppressed ones technically? No, NMS removes them before metrics in standard eval usually,
        // or they are counted as FP if not suppressed? Standard: NMS is pre-processing. Suppressed boxes don't count for metrics.

        const fn = groundTruths.filter((g) => g.status === "FN").length;

        // 4. Update UI
        document.getElementById("tp-count").textContent = tp;
        document.getElementById("fp-count").textContent = fp;
        document.getElementById("fn-count").textContent = fn;
        if (!showGridCheck.checked)
          document.getElementById("tn-count").textContent = "N/A";

        const pFinal = tp + fp === 0 ? 0 : tp / (tp + fp);
        const rFinal = totalGT === 0 ? 0 : tp / totalGT;
        const f1 =
          pFinal + rFinal === 0
            ? 0
            : (2 * (pFinal * rFinal)) / (pFinal + rFinal);

        document.getElementById("precision-val").textContent =
          pFinal.toFixed(4);
        document.getElementById("recall-val").textContent = rFinal.toFixed(4);
        document.getElementById("f1-val").textContent = f1.toFixed(4);

        // AP Calculation
        let ap = 0;
        if (prPoints.length > 0) {
          let recs = [0, ...prPoints.map((p) => p.x)];
          let precs = [prPoints[0].y, ...prPoints.map((p) => p.y)];
          // Smooth
          for (let i = precs.length - 2; i >= 0; i--)
            precs[i] = Math.max(precs[i], precs[i + 1]);
          // Integrate
          for (let i = 1; i < recs.length; i++)
            ap += (recs[i] - recs[i - 1]) * precs[i];
        }
        document.getElementById("ap-val").textContent = ap.toFixed(4);

        drawAll();
        drawChart(prPoints);
        updateLogTable();
        generateReport(pFinal, rFinal, ap, doNms, nmsThresh);
      }

      function updateLogTable() {
        const tbody = document.getElementById("log-table-body");
        tbody.innerHTML = "";
        // Sort: TP -> FP -> Suppressed
        const sorted = [...predictions].sort((a, b) => {
          const order = { TP: 1, FP: 2, SUPPRESSED: 3, UNKNOWN: 4 };
          return order[a.status] - order[b.status] || b.score - a.score;
        });

        sorted.forEach((p, idx) => {
          const tr = document.createElement("tr");
          let statusClass = "text-gray-600";
          if (p.status === "TP") statusClass = "text-green-600 font-bold";
          if (p.status === "FP") statusClass = "text-red-600 font-bold";
          if (p.status === "SUPPRESSED")
            statusClass = "text-gray-400 italic decoration-line-through";

          tr.innerHTML = `
                    <td class="px-2 py-1 border-b">${idx + 1}</td>
                    <td class="px-2 py-1 border-b font-mono">${p.score.toFixed(
                      2
                    )}</td>
                    <td class="px-2 py-1 border-b font-mono">${p.iou.toFixed(
                      2
                    )}</td>
                    <td class="px-2 py-1 border-b ${statusClass}">${
            p.status
          }</td>
                `;
          tbody.appendChild(tr);
        });
      }

      function generateReport(p, r, ap, nmsActive, nmsThresh) {
        const el = document.getElementById("scientific-conclusion");
        let text = `<b>Kết luận:</b> Với AP=${ap.toFixed(
          2
        )}, hệ thống có hiệu năng ${
          ap > 0.8 ? "xuất sắc" : ap > 0.5 ? "trung bình" : "thấp"
        }. `;

        if (nmsActive) {
          text += `Việc áp dụng <b>NMS</b> (Ngưỡng ${nmsThresh}) đã giúp loại bỏ các dự đoán trùng lặp. `;
          const suppressedCount = predictions.filter(
            (x) => x.status === "SUPPRESSED"
          ).length;
          if (suppressedCount > 0)
            text += `Cụ thể, có ${suppressedCount} box bị triệt tiêu để giảm FP. `;
        } else {
          text += `<b>Cảnh báo:</b> NMS đang tắt. Precision có thể bị giảm do nhiều box dư thừa bao quanh một đối tượng. `;
        }

        if (p > r)
          text += `Mô hình thiên về độ chính xác (Precision=${p.toFixed(
            2
          )} > Recall=${r.toFixed(2)}). `;
        else if (r > p)
          text += `Mô hình thiên về độ phủ (Recall=${r.toFixed(
            2
          )} > Precision=${p.toFixed(2)}). `;

        el.innerHTML = text;
      }

      function drawChart(data) {
        const ctxChart = document.getElementById("prChart").getContext("2d");
        if (prChartInstance) prChartInstance.destroy();
        const pts = data.map((p) => ({ x: p.x, y: p.y }));
        if (pts.length === 0) pts.push({ x: 0, y: 0 });

        prChartInstance = new Chart(ctxChart, {
          type: "line",
          data: {
            datasets: [
              {
                label: "PR Curve",
                data: pts,
                borderColor: "#4f46e5",
                backgroundColor: "rgba(79, 70, 229, 0.1)",
                fill: true,
                tension: 0.1,
                pointRadius: 3,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: {
                type: "linear",
                min: 0,
                max: 1.05,
                title: { display: true, text: "Recall" },
              },
              y: {
                min: 0,
                max: 1.05,
                title: { display: true, text: "Precision" },
              },
            },
            plugins: { legend: { display: false } },
          },
        });
      }

      function downloadReport() {
        // Simple screenshot of the body (user can crop) or specific div
        // Using html2canvas
        const element = document.body;
        html2canvas(element).then((canvas) => {
          const link = document.createElement("a");
          link.download = "object_detection_report.png";
          link.href = canvas.toDataURL();
          link.click();
        });
      }

      // Init
      drawAll();
    </script>
  </body>
</html>
